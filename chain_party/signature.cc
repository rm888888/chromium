//
//  signature.cpp
//  sources
//
//  Created by 007 on 2022/1/18.
//

#include "signature.h"
//#include "/Volumes/Data/third_party/Libwally/libwally-core/include/wally.hpp"

#include "/Volumes/Data/third_party/Libwally/libwally-core/include/wally_core.h"
#include "/Volumes/Data/third_party/Libwally/libwally-core/include/wally_bip32.h"
#include "/Volumes/Data/third_party/Libwally/libwally-core/include/wally_bip39.h"
#include "/Volumes/Data/third_party/Libwally/libwally-core/include/wally_address.h"

#include "/Volumes/Data/third_party/Libwally/libwally-core/include/wally_psbt.h"
#include "/Volumes/Data/third_party/Libwally/libwally-core/include/wally_script.h"

//test
//#include "/Users/pundix007/Desktop/macproject/cplusplus_project/libraryTest/library.h"
//#include "testlib/testClass.h"
//
Signature::Signature()
{
    //create dir and empty file
    std::string exepath = GlobalHelp::GetAppRunPath();
    libwally_path = exepath +"/libwallycore/libwallycore.0.dylib";
    std::string userpath = GlobalHelp::GetUsersPath();
    chain_file_path = userpath + "/chainparty";
    GlobalHelp::CreateDir((char*)chain_file_path.data());
    chain_file_path += "/chain.txt";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),NULL,0);
    //update on 20220324
    /*auto result = sum(8,19);
    char* tl = new char[100];
    sprintf(tl,"%d",result);
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),tl,0);*/
    //TestClass* obj = new TestClass();
    //obj->readJsonString();
}
void Signature::LoadWallyCore()
{
    void* dylib = dlopen((char*)libwally_path.c_str(),RTLD_LOCAL | RTLD_LAZY);
    if(dylib == NULL)
        return;
    //update on 20220118 context create
    wally_init1 = (Wally_init)dlsym(dylib, "wally_init");
    bip39_mnemonic_from_bytes1 = (Bip39_mnemonic_from_bytes)dlsym(dylib, "bip39_mnemonic_from_bytes");
    bip39_mnemonic_to_seed1 = (Bip39_mnemonic_to_seed)dlsym(dylib, "bip39_mnemonic_to_seed");
    wally_free_string1 = (Wally_free_string)dlsym(dylib, "wally_free_string");
    bip32_key_from_seed_alloc1 = (Bip32_key_from_seed_alloc)dlsym(dylib, "bip32_key_from_seed_alloc");
    bip32_key_to_base581 = (Bip32_key_to_base58)dlsym(dylib, "bip32_key_to_base58");
    bip32_key_from_parent_path_alloc1 = (Bip32_key_from_parent_path_alloc)dlsym(dylib, "bip32_key_from_parent_path_alloc");
    wally_bip32_key_to_addr_segwit1 = (Wally_bip32_key_to_addr_segwit)dlsym(dylib, "wally_bip32_key_to_addr_segwit");
    wally_bip32_key_to_address1 = (Wally_bip32_key_to_address)dlsym(dylib, "wally_bip32_key_to_address");
    
    wally_psbt_from_base641 = (Wally_psbt_from_base64)dlsym(dylib, "wally_psbt_from_base64");
    wally_scriptpubkey_p2pkh_from_bytes1 = (Wally_scriptpubkey_p2pkh_from_bytes)dlsym(dylib, "wally_scriptpubkey_p2pkh_from_bytes");
    wally_tx_get_btc_signature_hash1 = (Wally_tx_get_btc_signature_hash)dlsym(dylib, "wally_tx_get_btc_signature_hash");
    wally_ec_sig_from_bytes1 = (Wally_ec_sig_from_bytes)dlsym(dylib, "wally_ec_sig_from_bytes");
    bip32_key_free1 = (Bip32_key_free)dlsym(dylib, "bip32_key_free");
    wally_ec_sig_to_der1 = (Wally_ec_sig_to_der)dlsym(dylib, "wally_ec_sig_to_der");
    wally_psbt_to_base641 = (Wally_psbt_to_base64)dlsym(dylib, "wally_psbt_to_base64");
    wally_psbt_free1 = (Wally_psbt_free)dlsym(dylib, "wally_psbt_free");
    wally_cleanup1 = (Wally_cleanup)dlsym(dylib, "wally_cleanup");
    //
    char test[] = "load dll suc \n";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),test,1);
    libwally_example();
    //update on 20220711
    dlclose(dylib);
}

void  Signature::libwally_example(){
    size_t len; // to store length of serialization etc
    int res = -1 ;   // to store wally's results

    std::string out_param = "";
    std::string temp_buff = "";
    // we need to initialize libwally first
    res = wally_init1(0);
    out_param = "wally_init1:suc \n";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);

    /**************** BIP-39 recovery phrase ******************/

    // random buffer should be generated by TRNG or somehow else
    // but we will use predefined one for demo purposes
    // 16 bytes will generate a 12-word recovery phrase
    uint8_t rnd[] = {
        0xbd, 0xb5, 0x1a, 0x16, 0xeb, 0x64, 0x60, 0xec,
        0x16, 0xf8, 0x4d, 0x7b, 0x6f, 0x19, 0xe2, 0x0d,
        0xbd, 0xb5, 0x1a, 0x16, 0xeb, 0x64, 0x60, 0xec,
        0x16, 0xf8, 0x4d, 0x7b, 0x6f, 0x19, 0xe2, 0x0d
    };

    // creating a recovery phrase
    char *phrase = NULL;
    res = bip39_mnemonic_from_bytes1(NULL, rnd, sizeof(rnd), &phrase);
    printf("Recovery phrase: %s\r\n", phrase);
    temp_buff = phrase;
    out_param = "Recovery phrase: " + temp_buff + "\n";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
    // converting recovery phrase to seed
    uint8_t seed[BIP39_SEED_LEN_512];
    res = bip39_mnemonic_to_seed1(phrase, "my password", seed, sizeof(seed), &len);
    out_param = "bip39_mnemonic_to_seed1 suc\n";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
    // don't forget to securely clean up the string when done
    wally_free_string1(phrase);
    printf("%d",res);
    printf("Seed: ");
    //println_hex(seed, sizeof(seed));
    char temp_p[BIP39_SEED_LEN_512*2+1] = {0};
    GlobalHelp::ByteToHexstring(seed,sizeof(seed),temp_p);
    temp_buff = temp_p;
    out_param = "Seed: " + temp_buff + "\n";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
    /**************** BIP-32 HD keys ******************/

    // root HD key
    struct ext_key * root = NULL;
    res = bip32_key_from_seed_alloc1(seed, sizeof(seed), BIP32_VER_TEST_PRIVATE, 0, &root);
    // get base58 xprv string
    char *xprv = NULL;
    res = bip32_key_to_base581(root, BIP32_FLAG_KEY_PRIVATE, &xprv);
    printf("Root key: %s\r\n", xprv);
    temp_buff = xprv;
    out_param = "Root key: " + temp_buff + "\n";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
    // don't forget to securely clean up the string when done
    wally_free_string1(xprv);
    // deriving account key for native segwit, testnet: m/84h/1h/0h
    struct ext_key * account = NULL;
    uint32_t path[] = {
        BIP32_INITIAL_HARDENED_CHILD+84, // 84h
        BIP32_INITIAL_HARDENED_CHILD+1,  // 1h
        BIP32_INITIAL_HARDENED_CHILD     // 0h
    };
    res = bip32_key_from_parent_path_alloc1(root, path, 3, BIP32_FLAG_KEY_PRIVATE, &account);

    res = bip32_key_to_base581(account, BIP32_FLAG_KEY_PRIVATE, &xprv);
    printf("Account private key: %s\r\n", xprv);
    temp_buff = xprv;
    out_param = "Account private key: " + temp_buff + "\n";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
    // don't forget to securely clean up the string when done
    wally_free_string1(xprv);
    char *xpub = NULL;
    res = bip32_key_to_base581(account, BIP32_FLAG_KEY_PUBLIC, &xpub);
    printf("Account public key: %s\r\n", xpub);
    temp_buff = xpub;
    out_param = "Account public key: " + temp_buff + "\n";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
    // fingerprint
    printf("Derivation information: [");
    //print_hex(root->hash160, 4);
    printf("/84h/1h/0h]%s\r\n", xpub);
    // don't forget to securely clean up the string when done
    wally_free_string1(xpub);

    /**************** Addresses ******************/
    // key for the first address
    struct ext_key * first_recv = NULL;
    uint32_t recv_path[] = {0, 0};
    // we only need public key here, no need in private key
    res = bip32_key_from_parent_path_alloc1(account, recv_path, 2, BIP32_FLAG_KEY_PUBLIC, &first_recv);
    char  *addr = NULL;

    // native segwit address
    res = wally_bip32_key_to_addr_segwit1(first_recv, "tb", 0, &addr);
    printf("Segwit address: %s\r\n", addr);
    
    temp_buff = addr;
    out_param = "Segwit address: " + temp_buff + "\n";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
    wally_free_string1(addr);
    // nested segwit address
    res = wally_bip32_key_to_address1(first_recv, WALLY_ADDRESS_TYPE_P2SH_P2WPKH, WALLY_ADDRESS_VERSION_P2SH_TESTNET, &addr);
    printf("Nested segwit address: %s\r\n", addr);
    
    temp_buff = addr;
    out_param = "Nested segwit address: " + temp_buff + "\n";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
    wally_free_string1(addr);
    // legacy address
    res = wally_bip32_key_to_address1(first_recv, WALLY_ADDRESS_TYPE_P2PKH, WALLY_ADDRESS_VERSION_P2PKH_TESTNET, &addr);
    printf("Legacy address: %s\r\n", addr);
    
    temp_buff = addr;
    out_param = "Legacy address: " + temp_buff + "\n";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
    wally_free_string1(addr);
    //update on 20220120
    //return;
    
    
    /**************** PSBT ******************/

    char b64_psbt[] = "cHNidP8BAHICAAAAAX7U8W8nyYJcYzFjoHa5UH5j0Ug43ej/q2bf"
                          "IPq8XnjeAAAAAAD/////AihATAAAAAAAFgAUPE9Ix5e2qWWcDW78"
                          "DM+uqX09ANNAS0wAAAAAABepFPPNvp1TAyho+Kys4wwejY8iakgQ"
                          "hwAAAAAAAQEfgJaYAAAAAAAWABRy2Nt/+F2j9EYd2bcI5CfSqeey"
                          "MSIGAmijc35Kh8Nfa9oC0jGb2I1UfzkS0MqAfHw0BKA6JRwuGCbd"
                          "2XhUAACAAQAAgAAAAIAAAAAAAAAAAAAiAgOTSWH+F+K8DsY9lzWM"
                          "QZJptjBUmMVgdE+1814LZMwVFRgm3dl4VAAAgAEAAIAAAACAAQAAAAAAAAAAAA==";
    struct wally_psbt * psbt = NULL;
    res = wally_psbt_from_base641(b64_psbt, &psbt);

    //print_psbt(psbt);

    for(int i = 0; i < (int)psbt->num_inputs; i++){
        if(!psbt->inputs[i].witness_utxo){
            printf("Too lazy for legacy");
            return;
        }
        uint8_t hash[32];
        uint8_t script[25];
        printf("scriptpubkey: ");
        //println_hex(psbt->inputs[i].witness_utxo->script, psbt->inputs[i].witness_utxo->script_len);
        wally_scriptpubkey_p2pkh_from_bytes1(
            psbt->inputs[i].witness_utxo->script+2, 20,
            0,
            script, 25, &len);
        printf("scriptpubkey: ");
        //println_hex(script, len);
        GlobalHelp::ByteToHexstring(script,sizeof(script),temp_p);
        temp_buff = temp_p;
        out_param = "scriptpubkey: " + temp_buff + "\n";
        GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
        wally_tx_get_btc_signature_hash1(psbt->tx, i,
                script, len,
                psbt->inputs[i].witness_utxo->satoshi,
                WALLY_SIGHASH_ALL,
                WALLY_TX_FLAG_USE_WITNESS,
                hash, 32
            );
        printf("Input %d. Hash to sign: ", i);
        GlobalHelp::ByteToHexstring(hash,sizeof(hash),temp_p);
        temp_buff = temp_p;
        out_param = "Hash to sign: " + temp_buff + "\n";
        GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
        //println_hex(hash, 32);
        struct ext_key * pk = NULL;
//        bip32_key_from_parent_path_alloc(root,
//            psbt->inputs[i].keypaths.items[0].origin.path,
//            psbt->inputs[i].keypaths.items[0].origin.path_len,
//            BIP32_FLAG_KEY_PRIVATE, &pk);
        bip32_key_from_parent_path_alloc1(root,
                                         path,sizeof(path),
            BIP32_FLAG_KEY_PRIVATE, &pk);
        
        uint8_t sig[EC_SIGNATURE_LEN];
        wally_ec_sig_from_bytes1(
                pk->priv_key+1, 32, // first byte of ext_key.priv_key is 0x00
                hash, 32,
                EC_FLAG_ECDSA,
                sig, EC_SIGNATURE_LEN
            );
        bip32_key_free1(pk);
        GlobalHelp::ByteToHexstring(sig,sizeof(sig),temp_p);
        temp_buff = temp_p;
        signature_result = temp_buff;
        out_param = "Sign: " + temp_buff + "\n";
        GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
        uint8_t der[EC_SIGNATURE_DER_MAX_LEN+1];
        wally_ec_sig_to_der1(
                sig, EC_SIGNATURE_LEN,
                der, EC_SIGNATURE_DER_MAX_LEN,
                &len
            );
        der[len] = WALLY_SIGHASH_ALL;
//        if(!psbt->inputs[i]->partial_sigs){
//            partial_sigs_map_init_alloc(1, &psbt->inputs[i]->partial_sigs);
//        }
//        add_new_partial_sig(psbt->inputs[i]->partial_sigs,
//                pk->pub_key,
//                der, len+1
//            );
    }

    char * output;
    wally_psbt_to_base641(psbt, 0,&output);
    wally_psbt_free1(psbt);

    printf("PSBT: %s\r\n", output);
    temp_buff = output;
    out_param = "PSBT: " + temp_buff + "\n";
    GlobalHelp::WriteInfoToFile((char*)chain_file_path.c_str(),(char*)out_param.c_str(),1);
    wally_free_string1(output);

    bip32_key_free1(root);
    bip32_key_free1(account);
    wally_cleanup1(0);
    
}

char* Signature::GetSignature()
{
    return (char*)signature_result.c_str();
}
